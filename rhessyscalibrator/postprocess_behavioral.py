"""@package rhessyscalibrator.postprocess_behavioral

@brief Tool for analyzing model run results generated by rhessys_calibrator_behavioral.py and 
stored in a database format managed by rhessyscalibrator.model_runner_db.py.  Currently
plots 95% uncertainty bounds around observed streamflow using NSE as a likelihood function.

This software is provided free of charge under the New BSD License. Please see
the following license information:

Copyright (c) 2013, University of North Carolina at Chapel Hill
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the University of North Carolina at Chapel Hill nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


@author Brian Miles <brian_miles@unc.edu>
"""
import os, sys, errno
import argparse
import logging
from datetime import datetime

import math
import numpy
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib

from rhessyscalibrator.postprocess import RHESSysCalibratorPostprocess
from rhessyscalibrator.calibrator import RHESSysCalibrator
from rhessyscalibrator.model_runner_db import *

class RHESSysCalibratorPostprocessBehavioral(object):
    """ Main driver class for rhessys_calibrator_postprocess_behavioral tool
    """
    
    def saveUncertaintyBoundsPlot(self, outDir, filename, lowerBound, upperBound,
                                  format='PDF', log=False, xlabel=None, ylabel=None,
                                  title=None, plotObs=True, plotMean=False, plotColor=False,
                                  legend=True, sizeX=1, sizeY=1, dpi=80):
        """ Save uncertainty bounds plot to outDir
        
            @param lowerBound Float <100.0, >0.0, <upperBound
            @param upperBound Float <100.0, >0.0, >lowerBound
        """
        assert( format in ['PDF', 'PNG'] )
        if format == 'PDF':
            plotFilename = "%s.pdf" % (filename,)
        elif format == 'PNG':
            plotFilename = "%s.png" % (filename,)
        plotFilepath = os.path.join(outDir, plotFilename)
        
        assert( lowerBound < 100.0 and lowerBound > 0.0)
        assert( upperBound < 100.0 and upperBound > 0.0)
        assert( lowerBound < upperBound )
        assert( self.x is not None )
        assert( self.ysim is not None )
        
        if plotColor:
            fillColor = '0.5'
            obs_color = 'blue'
            mean_color = 'yellow'
        else:
            fillColor = '0.5'
            obs_color = 'black'
            mean_color = '0.75'
        
        # Normalize likelihood to have values from 0 to 1
        normLH = self.likelihood / numpy.sum(self.likelihood)
        
        lower = lowerBound / 100.0
        upper = upperBound / 100.0
        
        # Get the uncertainty boundary
        nIters = numpy.shape(self.ysim)[1]
        minYsim = numpy.zeros(nIters)
        maxYsim = numpy.zeros(nIters)
        meanYsim = numpy.zeros(nIters)

        # Generate uncertainty interval bounded by lower bound and upper bound
        for i in xrange(0, nIters):
            ys = self.ysim[:,i]
            # Use CDF of likelihood values as basis for interval
            sortedIdx = numpy.argsort(ys)
            sortYsim = ys[sortedIdx]
            sortLH = normLH[sortedIdx]
            cumLH = numpy.cumsum(sortLH)
            cond = (cumLH > lower) & (cumLH < upper)
            
            validYsim = sortYsim[cond]
            minYsim[i] = validYsim[0]
            maxYsim[i] = validYsim[-1]
            meanYsim[i] = validYsim.mean()
            
        # Plot it up
        fig = plt.figure(figsize=(sizeX, sizeY), dpi=dpi, tight_layout=True)
        ax = fig.add_subplot(111)
        
        data_plt = []
        legend_items = []
        # Draw observed line
        if plotObs:
            (p, ) = ax.plot(self.x, self.obs, color=obs_color, linestyle='solid')
            data_plt.append(p)
            legend_items.append('Observed data')
        if plotMean:
            (p, ) = ax.plot(self.x, meanYsim, color=mean_color, linestyle='solid')
            data_plt.append(p)
            legend_items.append('Mean')
        # Draw shaded uncertainty envelope
        ax.fill_between(self.x, minYsim, maxYsim, color=fillColor)
        
        # Annotations
        # X-axis
        quarterly = matplotlib.dates.MonthLocator(interval=3)
        ax.xaxis.set_major_locator(quarterly)
        ax.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%b-%Y') )
        # Rotate
        plt.setp( ax.xaxis.get_majorticklabels(), rotation=45 )
        plt.setp( ax.xaxis.get_majorticklabels(), fontsize='xx-small' )
        
        if log:
            ax.set_yscale('log')
        
        if xlabel:
            ax.set_xlabel(xlabel)
        if ylabel:
            ax.set_ylabel(ylabel)
        if title:
            fig.suptitle(title, y=0.99)
            
        # Plot legend last
        if legend:
            legend = ax.legend( data_plt, legend_items, 'upper left', fontsize='x-small', 
                                ncol=len(legend_items)/2, frameon=True )
            frame = legend.get_frame()
            frame.set_facecolor('0.9')
            frame.set_alpha(0.5)
            
        # Save the figure
        fig.savefig(plotFilepath, format=format, bbox_inches='tight', pad_inches=0.25)
        
    
    def _initLogger(self, level):
        """ Setup logger.  Log to the console for now """
        self.logger = logging.getLogger("cluster_calibrator")
        self.logger.setLevel(level)
        # console handler and set it to level
        consoleHandler = logging.StreamHandler()
        consoleHandler.setLevel(level)
        # create formatter
        formatter = \
            logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        # add formatter to console handler
        consoleHandler.setFormatter(formatter)
        # add consoleHandler to logger
        self.logger.addHandler(consoleHandler)
        
    
    def main(self, args):
        # Set up command line options
        parser = argparse.ArgumentParser(description="Tool for visualizing output from behavioral model runs for RHESSys")
        parser.add_argument("-b", "--basedir", action="store", 
                            dest="basedir", required=True,
                            help="Base directory for the calibration session")
        
        parser.add_argument("-s", "--behavioral_session", action="store", type=int,
                            dest="session_id", required=True,
                            help="Session to use for behavioral runs.")
        
        parser.add_argument("-t", "--title", action="store",
                            dest="title",
                            help="Title to add to output figures")
        
        parser.add_argument("-o", "--outdir", action="store",
                            dest="outdir",
                            help="Output directory in which to place dotty plot figures.  If not specified, basedir will be used.")

        parser.add_argument("-f", "--file", action="store",
                            dest="observed_file",
                            help="The name of the observed file to use for calculating model fitness statistics.  Filename will be interpreted as being relative to $BASEDIR/obs. If not supplied observation file from calibration model run will be used.")

        parser.add_argument("-of", "--outputFormat", action="store",
                            dest="outputFormat", default="PDF", choices=["PDF", "PNG"],
                            help="Output format to save figures in.")

        parser.add_argument("--behavioral_filter", action="store",
                            dest="behavioral_filter", required=False,
                            default="nse>0.5 and nse_log>0.5",
                            help="SQL where clause to use to determine which runs qualify as behavioral parameters.  E.g. 'nse>0.5 AND nse_log>0.5' (use quotes)")

        parser.add_argument("--supressObs", action="store_true", required=False, default=False,
                            help="Do not plot observered data")

        parser.add_argument("--plotMean", action="store_true", required=False, default=False,
                            help="Plot mean value of behavioral runs")

        parser.add_argument("--color", action="store_true", required=False, default=False,
                            help="Plot in color")
        
        parser.add_argument("--legend", action="store_true", required=False, default=False,
                            help="Show legend")
        
        parser.add_argument('--figureX', required=False, type=int, default=4,
                            help='The width of the plot, in inches')
    
        parser.add_argument('--figureY', required=False, type=int, default=3,
                            help='The height of the plot, in inches')

        parser.add_argument("-l", "--loglevel", action="store",
                            dest="loglevel", default="OFF",
                            help="Set logging level, one of: OFF [default], DEBUG, CRITICAL (case sensitive)")
        
        options = parser.parse_args()
        
        # Enforce initial command line options rules
        if "DEBUG" == options.loglevel:
            self._initLogger(logging.DEBUG)
        elif "CRITICAL" == options.loglevel:
            self._initLogger(logging.CRITICAL)
        else:
            self._initLogger(logging.NOTSET)
        
        if not os.path.isdir(options.basedir) or not os.access(options.basedir, os.W_OK):
            sys.exit("Unable to write to basedir %s" % (options.basedir,) )
        basedir = os.path.abspath(options.basedir)
        
        if not options.outdir:
            options.outdir = basedir
            
        if not os.path.isdir(options.outdir) and os.access(options.outdir, os.W_OK):
            parser.error("Figure output directory %s must be a writable directory" % (options.outdir,) )
        outdirPath = os.path.abspath(options.outdir)

        dbPath = RHESSysCalibrator.getDBPath(basedir)
        if not os.access(dbPath, os.R_OK):
            raise IOError(errno.EACCES, "The database at %s is not readable" %
                          dbPath)
        self.logger.debug("DB path: %s" % dbPath)
        
        outputPath = RHESSysCalibrator.getOutputPath(basedir)
        if not os.access(outputPath, os.R_OK):
            raise IOError(errno.EACCES, "The output directory %s is  not readable" % outputPath)
        self.logger.debug("Output path: %s" % outputPath)

        rhessysPath = RHESSysCalibrator.getRhessysPath(basedir)
        
        try:
            calibratorDB = \
                ModelRunnerDB(RHESSysCalibrator.getDBPath(
                    basedir))
        
            # Make sure the session exists
            session = calibratorDB.getSession(options.session_id)
            if None == session:
                raise Exception("Session %d was not found in the calibration database %s" % (options.session_id, dbPath))
            if session.status != "complete":
                print "WARNING: session status is: %s.  Some model runs may not have completed." % (session.status,)
            else:
                self.logger.debug("Session status is: %s" % (session.status,))
        
            # Deterine observation file path
            if options.observed_file:
                obs_file = options.observed_file
            else:
                # Get observered file from session
                assert( session.obs_filename != None )
                obs_file = session.obs_filename
            obsPath = RHESSysCalibrator.getObsPath(basedir)
            obsFilePath = os.path.join(obsPath, obs_file)
            if not os.access(obsFilePath, os.R_OK):
                raise IOError(errno.EACCES, "The observed data file %s is  not readable" % obsFilePath)
            self.logger.debug("Obs path: %s" % obsFilePath)
            
            # Get runs in session
            runs = calibratorDB.getRunsInSession(session.id, where_clause=options.behavioral_filter)
            numRuns = len(runs) 
            if numRuns == 0:
                raise Exception("No runs found for session %d" 
                                % (session.id,))
            response = raw_input("%d runs selected for plotting from session %d, continue? [yes | no] " % \
                                (numRuns, options.session_id ) )
            response = response.lower()
            if response != 'y' and response != 'yes':
                # Exit normally
                return 0
            self.logger.debug("%d behavioral runs" % (numRuns,) )
            
            # Read observed data from file
            obsFile = open(obsFilePath, 'r')
            (self.obs_datetime, self.obs_data) = \
                RHESSysCalibratorPostprocess.readObservedDataFromFile(obsFile)
            obsFile.close()
            obs = pd.Series(self.obs_data, index=self.obs_datetime)

            self.logger.debug("Observed data: %s" % self.obs_data)
            
            self.likelihood = numpy.empty(numRuns)
            self.ysim = None
            self.x = None
            
            runsProcessed = False
            for (i, run) in enumerate(runs):
                if "DONE" == run.status:
                    runOutput = os.path.join(rhessysPath, run.output_path)
                    self.logger.debug(">>>\nOutput dir of run %d is %s" %
                                         (run.id, runOutput))
                    tmpOutfile = \
                        RHESSysCalibrator.getRunOutputFilePath(runOutput)
                    if not os.access(tmpOutfile, os.R_OK):
                        print "Output file %s for run %d not found or not readable, unable to calculate fitness statistics for this run" % (tmpOutfile, run.id)
                        continue
                    
                    tmpFile = open(tmpOutfile, 'r')
                    
                    (tmp_datetime, tmp_data) = \
                            RHESSysCalibratorPostprocess.readColumnFromFile(tmpFile,
                                                                            "streamflow")
                    tmp_mod = pd.Series(tmp_data, index=tmp_datetime)
                    # Align timeseries to observed
                    (mod, self.obs) = tmp_mod.align(obs, join='inner')
                    
                    #import pdb; pdb.set_trace()
                    
                    # Stash date for X values (assume they are the same for all runs
                    if self.x == None:
                        #self.x = numpy.array(mod.index)
                        self.x = [datetime.strptime(str(d), '%Y-%m-%d %H:%M:%S') for d in mod.index]
                        
                    #import pdb; pdb.set_trace()    
                    
                    # Put data in matrix
                    dataLen = len(mod)
                    if self.ysim == None:
                        # Allocate matrix for results
                        self.ysim = numpy.empty( (numRuns, dataLen) )
                    assert( numpy.shape(self.ysim)[1] == dataLen )
                    self.ysim[i,] = mod
                    
                    # Store fitness parameter
                    self.likelihood[i] = run.nse
                            
                    tmpFile.close()                
                    runsProcessed = True
                    
            if runsProcessed:
                behavioralFilename = 'behavioral'
                if options.supressObs:
                    behavioralFilename += '_noObs'
                if options.plotMean:
                    behavioralFilename += '_mean'
                if options.color:
                    behavioralFilename += '_color'
                if options.legend:
                    behavioralFilename += '_legend'
                behavioralFilename += "_SESSION_%s" % ( options.session_id, )
                # Generate visualizations
                self.saveUncertaintyBoundsPlot(outdirPath, behavioralFilename, 
                                               2.5, 97.5, format=options.outputFormat, log=False,
                                               ylabel=r'Streamflow ($mm^{-d}$)',
                                               title=options.title, 
                                               plotObs=(not options.supressObs),
                                               plotMean=options.plotMean,
                                               plotColor=options.color,
                                               legend=options.legend,
                                               sizeX=options.figureX, sizeY=options.figureY )
                behavioralFilename += '-log'
                self.saveUncertaintyBoundsPlot(outdirPath, behavioralFilename, 
                                               2.5, 97.5, format=options.outputFormat, log=True,
                                               ylabel=r'Streamflow ($mm^{-d}$)',
                                               title=options.title,
                                               plotObs=(not options.supressObs),
                                               plotMean=options.plotMean,
                                               plotColor=options.color,
                                               legend=options.legend,
                                               sizeX=options.figureX, sizeY=options.figureY )
        except:
            raise
        else:
            self.logger.debug("exiting normally")
            return 0
        finally:
            # Decrement reference count, this will (hopefully) allow __del__
            #  to be called on the once referenced object
            calibratorDB = None