"""@package rhessyscalibrator.postprocess

@brief Tool for analyzing model run results generated by rhessys_calibrator.py and 
stored in a database format managed by rhessyscalibrator.model_runner_db.py.  Currently
calculates NSE and NSE-log for each completed run in the calibration database.
Results can be viewed in the companion rhessys_calibrator_results.py

This software is provided free of charge under the New BSD License. Please see
the following license information:

Copyright (c) 2013, University of North Carolina at Chapel Hill
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the University of North Carolina at Chapel Hill nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


@author Brian Miles <brian_miles@unc.edu>
"""
import sys
import os
import errno
from optparse import OptionParser
import logging
import string

import math
import numpy

from rhessyscalibrator.calibrator import RHESSysCalibrator
from rhessyscalibrator.model_runner_db import *


class RHESSysCalibratorPostprocess(object):
    """ Main driver class for cluster_calibrator_postprocess tool
    """
    def __init__(self):
        pass

    def _initLogger(self, level):
        """ Setup logger.  Log to the console for now """
        self.logger = logging.getLogger("cluster_calibrator")
        self.logger.setLevel(level)
        # console handler and set it to level
        consoleHandler = logging.StreamHandler()
        consoleHandler.setLevel(level)
        # create formatter
        formatter = \
            logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        # add formatter to console handler
        consoleHandler.setFormatter(formatter)
        # add consoleHandler to logger
        self.logger.addHandler(consoleHandler)

    @classmethod
    def readObservedDataFromFile(cls, file, header=True):
        """ Reads the data from the observed data file.  Assumes that
            there is one data point per line.
            
            Arguments:
            file -- file object  The text file to read from
            header -- boolean    Specifies whether a header is present
                                  in the file.  If True, the first
                                  line of the file will be skipped
        
            Returns a list of floats containing the data from the file.  
            Returns an empty list if there were no data.
        """
        obs_data = []
        
        if header:
            file.readline()

        data = file.readline()
        while data:
            obs_data.append(float(data))
            data = file.readline()

        return obs_data

    @classmethod
    def readColumnFromFile(cls, file, column_name, sep=" "):
        """ Reads the specified column from the text file.  The file
            must have a header.
        
            Arguments:
            file -- file object  The text file to read from
            column_name -- The name of the column to return
            sep -- The field separator (defaults to " ")

            Returns a list of floats containing the column data.  Returns an
            empty list if the column had no data, or if the column was
            not found
        """
        col_data = []

        # Read the header line
        header = file.readline()
        headers = string.split(header, sep)
        col_idx = 0
        col_found = False
        # Find column_name in headers
        for col in headers:
            if col == column_name:
                col_found = True
                break
            col_idx += 1

        # We found column_name, read the data
        if col_found:
            data = file.readline()
            while data:
                cols = string.split(data, sep)
                col_data.append(float(cols[col_idx]))
                data = file.readline()

        return col_data

    @classmethod
    def logTransform(cls, list1, list2):
        """ Log10 transform two lists, filtering values <= 0 in each.  Lists
            must be of same cardinality.  List cardinality and list
            item parity will be maintained.  Thus, if list1[i] == 0,
            both list1[i] and list2[i] will be skipped over.  Original
            lists will be left unchanged.

            Arguments:
            list1 -- list   The first list
            list2 -- list   The second list

            Returns a tuple containing the filtered lists.
        """
        assert(len(list1) == len(list2))

        # Maybe find a way to more efficiently allocate these
        ret_list1 = list()
        ret_list2 = list()

        idx = 0
        for item in list1:
            if list1[idx] > 0 and list2[idx] > 0:
                ret_list1.append(math.log10(list1[idx]))
                ret_list2.append(math.log10(list2[idx]))
            idx += 1

        return (ret_list1, ret_list2)

    @classmethod
    def calculateNSE(cls, obs, model, obs_mean=None):
        """ Calculate Nash-Sutcliffe efficiency (NSE) (Moriasi et al. 2007).

            Arguments:
            obs -- list<float>   Observed data
            model -- list<float> Modeled data
            obs_avg -- float     Mean of obs data (if None will be calculated)

            Returns a float representing the NSE
        """
        if None == obs_mean:
            obs_mean = sum(obs) / len(obs)

        numerator = 0
        denominator = 0

        idx = 0
        for datum in model:
            numerator += (obs[idx] - model[idx]) ** 2
            denominator += (obs[idx] - obs_mean) ** 2
            idx += 1

        assert(denominator != 0)
        return 1 - (numerator / denominator)

    def main(self, args):

        # Set up command line options
        parser = OptionParser(usage="""%prog --basedir=BASEDIR --file=OBS_FILE --session=SESSION_ID [optional arguments ...]

Run "%prog --help" for detailed description of all options
""")
        parser.add_option("-b", "--basedir", action="store", type="string", 
                          dest="basedir",
                          help="[REQUIRED] base directory for the calibration session")

        parser.add_option("-f", "--file", action="store", type="string",
                          dest="observed_file",
                          help="[REQUIRED] the name of the observed file to use for calculating model fitness statistics.  Filename will be interpreted as being relative to $BASEDIR/obs")

        parser.add_option("-s", "--session", action="store", type="int",
                          dest="session_id",
                          help="[REQUIRED] the ID of the session for which model fitness statistics should be calculated")

        parser.add_option("-r", "--recalculate", action="store_true", 
                          dest="recalculate", 
                          help="[OPTIONAL] force recalculation of fitness statistics for each run in the session (will overwrite any existing.)")
        
        parser.add_option("--add_streamflow_and_gw", action="store_true",
                          dest="add_streamflow_and_gw",
                          help="[OPTIONAL] Add streamflow and gw.Qout columns instead of using streamflow alone")

        parser.add_option("-l", "--loglevel", action="store", type="string",
                          dest="loglevel", default="OFF",
                          help="[OPTIONAL] set logging level, one of: OFF [default], DEBUG, CRITICAL (case sensitive)")
        
        (options, args) = parser.parse_args()

        # Enforce initial command line options rules
        if "DEBUG" == options.loglevel:
            self._initLogger(logging.DEBUG)
        elif "CRITICAL" == options.loglevel:
            self._initLogger(logging.CRITICAL)
        else:
            self._initLogger(logging.NOTSET)
            
        if not options.basedir:
            parser.error("Please specify the basedir for the calibration session")
        
        if not options.session_id:
            parser.error("Please specify the ID of session for which you'd like t calculate model fitness statistics")

        if not options.observed_file:
            parser.error("Please specify the name of the observed file to use for calculating model fitness statistics")

        dbPath = RHESSysCalibrator.getDBPath(options.basedir)
        if not os.access(dbPath, os.R_OK):
            raise IOError(errno.EACCES, "The database at %s is not readable" %
                          dbPath)
        self.logger.debug("DB path: %s" % dbPath)

        obsPath = RHESSysCalibrator.getObsPath(options.basedir)
        obsFilePath = os.path.join(obsPath, options.observed_file)
        if not os.access(obsFilePath, os.R_OK):
            raise IOError(errno.EACCES, "The observed data file %s is  not readable" % obsFilePath)
        self.logger.debug("Obs path: %s" % obsFilePath)

        outputPath = RHESSysCalibrator.getOutputPath(options.basedir)
        if not os.access(outputPath, os.R_OK):
            raise IOError(errno.EACCES, "The output directory %s is  not readable" % outputPath)
        self.logger.debug("Output path: %s" % outputPath)

        rhessysPath = RHESSysCalibrator.getRhessysPath(options.basedir)

        try:
            calibratorDB = \
                ModelRunnerDB(RHESSysCalibrator.getDBPath(
                    options.basedir))
            
            # Make sure the session exists
            session = calibratorDB.getSession(options.session_id)
            if None == session:
                raise Exception("Session %d was not found in the calibration database %s" % (options.session_id, dbPath))
            if session.status != "complete":
                print "WARNING: session status is: %s.  Some model runs may not have completed." % (session.status,)
            else:
                self.logger.debug("Session status is: %s" % (session.status,))
            
            # Check to see if results have already been calculated, only
            #  continue if "force" option was specified
            if session.obs_filename != None:
                if options.recalculate:
                    print "Overwriting existing fitness statistics for session %d" % session.id
                else:
                    print "Existing fitness statistics found for session %d.\nUse --recalculate option to overwrite existing statistics" % session.id
                    return 0
                
            # Get runs in session
            runs = calibratorDB.getRunsInSession(session.id)
            if len(runs) == 0:
                raise Exception("No runs found for session %d" 
                                % (session.id,))
            
            # Read observed data from file
            obsFile = open(obsFilePath, 'r')
            obs_data = \
                RHESSysCalibratorPostprocess.readObservedDataFromFile(obsFile)
            obsFile.close()

            self.logger.debug("Observed data: %s" % obs_data)

            runsProcessed = False

            for run in runs:
                if "DONE" == run.status:
                    runOutput = os.path.join(rhessysPath, run.output_path)
                    self.logger.debug("Output dir of run %d is %s" %
                                         (run.id, runOutput))
                    tmpOutfile = \
                        RHESSysCalibrator.getRunOutputFilePath(runOutput)
                    if not os.access(tmpOutfile, os.R_OK):
                        print "Output file %s for run %d not found or not readable, unable to calculate fitness statistics for this run" % (tmpOutfile, run.id)
                        continue
                    
                    tmpFile = open(tmpOutfile, 'r')
                    
                    if options.add_streamflow_and_gw:
                        streamflow = \
                            numpy.array(RHESSysCalibratorPostprocess.readColumnFromFile(tmpFile, "streamflow"))
                        tmpFile.seek(0)
                        gw_Qout = \
                            numpy.array(RHESSysCalibratorPostprocess.readColumnFromFile(tmpFile, "gw.Qout"))
                        tmpResults = streamflow + gw_Qout
                                                            
                    else:
                        tmpResults = \
                            numpy.array(RHESSysCalibratorPostprocess.readColumnFromFile(tmpFile,
                                                                            "streamflow"))
                            
                    self.logger.debug("Output file %s: %s" % (tmpOutfile, tmpResults))
                    tmpFile.close()
            
                    # Make sure observed and modeled data are of the same
                    #   extent
                    my_obs_data = obs_data
                    if len(obs_data) > len(tmpResults):
                        my_obs_data = obs_data[:len(tmpResults)]
                        #my_log_obs_data = log_obs_data[:len(tmpResults)]
                    elif len(obs_data) < len(tmpResults):
                        tmpResults = tmpResults[:len(obs_data)]
                    assert(len(my_obs_data) == len(tmpResults))

                    # Calculate NSE
                    my_nse = \
                        RHESSysCalibratorPostprocess.calculateNSE(my_obs_data,
                                                                  tmpResults)
                    # Calculate NSE-log
                    # 1. Log-transform model data
                    (my_log_obs_data, log_tmpResults) = \
                        RHESSysCalibratorPostprocess.logTransform(my_obs_data,
                                                                  tmpResults)
                    # 2. NSE
                    my_nse_log = \
                        RHESSysCalibratorPostprocess.calculateNSE(my_log_obs_data, 
                                                                  log_tmpResults)

                    self.logger.debug("run %s, NSE: %s, NSE-log: %s" %
                                      (run.id, my_nse, my_nse_log))
                    
                    # Store fitness parameters for this run
                    calibratorDB.updateRunFitnessResults(run.id,
                                                         'daily',
                                                         my_nse,
                                                         my_nse_log)
                    runsProcessed = True

            if runsProcessed:
                # Update session with observed file name
                # options.observed_file
                calibratorDB.updateSessionObservationFilename(session.id,
                                                              options.observed_file)
        except:
            raise
        else:
            self.logger.debug("exiting normally")
            return 0
        finally:
            # Decrement reference count, this will (hopefully) allow __del__
            #  to be called on the once referenced object
            calibratorDB = None
